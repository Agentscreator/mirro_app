<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video Upload Test</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; }
        video { width: 300px; height: 200px; border: 1px solid #ccc; }
        button { padding: 10px 20px; margin: 5px; }
        .log { background: #f5f5f5; padding: 10px; margin: 10px 0; font-family: monospace; }
    </style>
</head>
<body>
    <h1>Video Upload Test</h1>
    
    <div>
        <video id="preview" autoplay muted></video>
        <video id="recorded" controls style="display: none;"></video>
    </div>
    
    <div>
        <button id="start">Start Camera</button>
        <button id="record" disabled>Start Recording</button>
        <button id="stop" disabled>Stop Recording</button>
        <button id="upload" disabled>Upload Video</button>
    </div>
    
    <div id="log" class="log"></div>
    
    <script>
        const log = document.getElementById('log');
        const preview = document.getElementById('preview');
        const recorded = document.getElementById('recorded');
        const startBtn = document.getElementById('start');
        const recordBtn = document.getElementById('record');
        const stopBtn = document.getElementById('stop');
        const uploadBtn = document.getElementById('upload');
        
        let stream = null;
        let mediaRecorder = null;
        let chunks = [];
        let recordedBlob = null;
        
        function addLog(message) {
            log.innerHTML += new Date().toLocaleTimeString() + ': ' + message + '<br>';
            log.scrollTop = log.scrollHeight;
            console.log(message);
        }
        
        // Test browser support
        addLog('MediaRecorder supported: ' + (typeof MediaRecorder !== 'undefined'));
        addLog('getUserMedia supported: ' + !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia));
        
        if (typeof MediaRecorder !== 'undefined') {
            const types = ['video/webm', 'video/webm;codecs=vp9', 'video/webm;codecs=vp8', 'video/mp4'];
            types.forEach(type => {
                addLog(`${type}: ${MediaRecorder.isTypeSupported(type)}`);
            });
        }
        
        startBtn.onclick = async () => {
            try {
                stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                preview.srcObject = stream;
                startBtn.disabled = true;
                recordBtn.disabled = false;
                addLog('Camera started successfully');
            } catch (error) {
                addLog('Camera error: ' + error.message);
            }
        };
        
        recordBtn.onclick = () => {
            chunks = [];
            
            let mimeType = 'video/webm';
            if (MediaRecorder.isTypeSupported('video/webm;codecs=vp9')) {
                mimeType = 'video/webm;codecs=vp9';
            } else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp8')) {
                mimeType = 'video/webm;codecs=vp8';
            }
            
            addLog('Using MIME type: ' + mimeType);
            
            mediaRecorder = new MediaRecorder(stream, { mimeType });
            
            mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    chunks.push(event.data);
                    addLog('Data chunk received: ' + event.data.size + ' bytes');
                }
            };
            
            mediaRecorder.onstop = () => {
                recordedBlob = new Blob(chunks, { type: mimeType });
                addLog('Recording stopped. Blob size: ' + recordedBlob.size + ' bytes');
                
                const url = URL.createObjectURL(recordedBlob);
                recorded.src = url;
                recorded.style.display = 'block';
                preview.style.display = 'none';
                
                uploadBtn.disabled = false;
            };
            
            mediaRecorder.start(1000);
            recordBtn.disabled = true;
            stopBtn.disabled = false;
            addLog('Recording started');
        };
        
        stopBtn.onclick = () => {
            mediaRecorder.stop();
            stream.getTracks().forEach(track => track.stop());
            stopBtn.disabled = true;
            addLog('Stopping recording...');
        };
        
        uploadBtn.onclick = async () => {
            if (!recordedBlob) {
                addLog('No video to upload');
                return;
            }
            
            try {
                const formData = new FormData();
                formData.append('file', recordedBlob, 'test-video.webm');
                formData.append('type', 'video');
                
                addLog('Uploading video...');
                
                const response = await fetch('/api/upload', {
                    method: 'POST',
                    body: formData
                });
                
                addLog('Upload response status: ' + response.status);
                
                if (response.ok) {
                    const result = await response.json();
                    addLog('Upload successful: ' + JSON.stringify(result));
                } else {
                    const error = await response.text();
                    addLog('Upload failed: ' + error);
                }
            } catch (error) {
                addLog('Upload error: ' + error.message);
            }
        };
    </script>
</body>
</html>